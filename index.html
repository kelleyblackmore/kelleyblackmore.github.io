<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Spinning Circle with Bouncing Balls</title>
  <style>
    body {
      background-color: black;
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      flex-direction: column;
    }

    #canvas-container {
      position: relative;
      text-align: center;
    }

    #gameCanvas {
      background-color: black;
      border: 2px solid white;
      display: block;
      margin: 0 auto;
    }

    #controls {
      margin-top: 20px;
    }

    button {
      padding: 10px 20px;
      margin: 5px;
      background-color: white;
      color: black;
      border: none;
      cursor: pointer;
      font-size: 16px;
      border-radius: 5px;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: gray;
    }

    /* Optional: Styling for the counter if moved outside the canvas */
    /*
    #counter {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 24px;
      color: white;
    }
    */
  </style>
</head>
<body>

  <div id="canvas-container">
    <canvas id="gameCanvas" width="600" height="600"></canvas>
    <!-- If you prefer the counter outside the canvas, uncomment below -->
    <!-- <div id="counter">Balls Exited: 0</div> -->
    <div id="controls">
      <button id="startBtn">Start</button>
      <button id="resetBtn">Reset</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const circleRadius = 250;
    const holeAngle = Math.PI / 6; // 30 degrees
    let angle = 0;
    let balls = [];
    let animationId;
    let gameStarted = false;

    // Ball counter variable
    let exitCount = 0;

    class Ball {
      constructor(x, y, radius, dx, dy, color) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.dx = dx;
        this.dy = dy;
        this.color = color;
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.closePath();
      }

      update() {
        this.x += this.dx;
        this.y += this.dy;

        // Calculate distance from center
        const distX = this.x - centerX;
        const distY = this.y - centerY;
        const distFromCenter = Math.sqrt(distX * distX + distY * distY);

        // Determine the current angle of the hole
        const currentHoleAngle = angle % (2 * Math.PI);

        // Calculate the angle of the ball relative to the center
        const ballAngle = Math.atan2(distY, distX);
        let relativeAngle = ballAngle - angle;
        // Normalize the angle between -PI and PI
        relativeAngle = (relativeAngle + Math.PI) % (2 * Math.PI) - Math.PI;

        // Define the range of angles that represent the hole
        const halfHole = holeAngle / 2;
        const isInHoleRange = Math.abs(relativeAngle) < halfHole;

        // Check if the ball is attempting to exit through the hole
        if (distFromCenter + this.radius > circleRadius && isInHoleRange) {
          return true; // Ball has exited through the hole
        }

        // Handle collision with the circle's boundary only if not in the hole's range
        if (distFromCenter + this.radius > circleRadius && !isInHoleRange) {
          // Calculate normal vector
          const normalX = distX / distFromCenter;
          const normalY = distY / distFromCenter;

          // Calculate velocity dot normal
          const dotProduct = this.dx * normalX + this.dy * normalY;

          // Reflect the velocity with added randomness
          const reflectionFactor = 2; // Standard reflection
          const randomAngle = (Math.random() - 0.5) * (Math.PI / 18); // +/-5 degrees in radians

          // Calculate new direction
          const newDx = (this.dx - reflectionFactor * dotProduct * normalX) + Math.cos(randomAngle) * 0.1;
          const newDy = (this.dy - reflectionFactor * dotProduct * normalY) + Math.sin(randomAngle) * 0.1;

          this.dx = newDx;
          this.dy = newDy;

          // Reposition the ball just inside the boundary to prevent sticking
          this.x = centerX + normalX * (circleRadius - this.radius - 1);
          this.y = centerY + normalY * (circleRadius - this.radius - 1);
        }

        return false; // Ball has not exited
      }
    }

    function spawnBall(initial = true) {
      const colors = ['red', 'green', 'blue', 'yellow', 'purple', 'orange', 'cyan', 'magenta'];
      const color = colors[Math.floor(Math.random() * colors.length)];
      const speed = initial ? (Math.random() * 2 + 2) : (Math.random() * 3 + 1.5);
      // Random direction
      const angle = Math.random() * 2 * Math.PI;
      const dx = Math.cos(angle) * speed;
      const dy = Math.sin(angle) * speed;
      const ball = new Ball(centerX, centerY, 10, dx, dy, color);
      balls.push(ball);
    }

    function drawSpinningCircle() {
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(angle);
      ctx.translate(-centerX, -centerY);
      ctx.beginPath();
      // Draw the circle with a hole by skipping the hole's arc
      ctx.arc(centerX, centerY, circleRadius, holeAngle / 2, 2 * Math.PI - holeAngle / 2);
      ctx.lineWidth = 5;
      ctx.strokeStyle = 'white';
      ctx.stroke();
      ctx.restore();
    }

    function drawCounter() {
      const counterText = `Balls Exited: ${exitCount}`;
      ctx.font = '24px Arial';
      ctx.fillStyle = 'white';
      ctx.textAlign = 'center';
      ctx.fillText(counterText, centerX, 40); // Positioned at top center
    }

    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw spinning circle with hole
      drawSpinningCircle();

      // Draw the counter
      drawCounter();

      // Update and draw balls
      for (let i = balls.length - 1; i >= 0; i--) {
        const ball = balls[i];
        ball.draw();
        if (ball.update()) {
          // Ball has exited through the hole
          balls.splice(i, 1); // Remove the exited ball
          exitCount++; // Increment the exit counter
          spawnBall(false); // Spawn two new balls
          spawnBall(false);
        }
      }

      // Spin the circle
      angle += 0.02; // Adjust rotation speed as needed
      angle %= 2 * Math.PI; // Keep the angle within 0 to 2Ï€

      animationId = requestAnimationFrame(animate);
    }

    // Start the game
    document.getElementById('startBtn').addEventListener('click', () => {
      if (!gameStarted) {
        gameStarted = true;
        balls = []; // Clear existing balls
        exitCount = 0; // Reset the counter
        spawnBall(); // Spawn the first ball
        animate();   // Start animation loop
      }
    });

    // Reset the game
    document.getElementById('resetBtn').addEventListener('click', () => {
      cancelAnimationFrame(animationId); // Stop the animation
      gameStarted = false;
      balls = []; // Clear all balls
      ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
      angle = 0; // Reset rotation angle
      exitCount = 0; // Reset the counter
    });

    // Optional: Allow resetting by pressing the 'R' key and starting with 'S'
    document.addEventListener('keydown', (e) => {
      if (e.key === 's' || e.key === 'S') {
        document.getElementById('startBtn').click();
      }
      if (e.key === 'r' || e.key === 'R') {
        document.getElementById('resetBtn').click();
      }
    });
  </script>

</body>
</html>