<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Spinning Circle with Bouncing Balls</title>
  <style>
    body {
      background-color: black;
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      flex-direction: column;
      font-family: Arial, sans-serif;
    }

    #canvas-container {
      position: relative;
      text-align: center;
    }

    #gameCanvas {
      background-color: black;
      border: 2px solid white;
      display: block;
      margin: 0 auto;
    }

    #controls {
      margin-top: 20px;
    }

    button {
      padding: 10px 20px;
      margin: 5px;
      background-color: white;
      color: black;
      border: none;
      cursor: pointer;
      font-size: 16px;
      border-radius: 5px;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: gray;
    }

    #counter {
      margin-bottom: 20px;
      font-size: 24px;
    }
  </style>
</head>
<body>

  <div id="counter">Balls Exited: 0</div>

  <div id="canvas-container">
    <canvas id="gameCanvas" width="600" height="600"></canvas>
    <div id="controls">
      <button id="startBtn">Start</button>
      <button id="resetBtn">Reset</button>
    </div>
  </div>

  <script>
    // Get DOM elements
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const resetBtn = document.getElementById('resetBtn');
    const counterDisplay = document.getElementById('counter');

    // Canvas center and circle parameters
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const circleRadius = 250;
    const holeAngle = Math.PI / 6; // 30 degrees

    // Rotation angle
    let angle = 0;

    // Array to hold balls
    let balls = [];

    // Animation frame ID
    let animationId;

    // Game state
    let gameStarted = false;

    // Ball exit counter
    let exitCount = 0;

    // Ball class definition
    class Ball {
      constructor(x, y, radius, dx, dy, color) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.dx = dx;
        this.dy = dy;
        this.color = color;
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.closePath();
      }

      update() {
        this.x += this.dx;
        this.y += this.dy;

        // Calculate distance from center
        const distX = this.x - centerX;
        const distY = this.y - centerY;
        const distFromCenter = Math.sqrt(distX * distX + distY * distY);

        // Calculate the angle of the ball relative to the center
        const ballAngle = Math.atan2(distY, distX);
        let relativeAngle = ballAngle - angle;
        // Normalize the angle between -PI and PI
        relativeAngle = (relativeAngle + Math.PI) % (2 * Math.PI) - Math.PI;

        // Define the range of angles that represent the hole
        const halfHole = holeAngle / 2;
        const isInHoleRange = Math.abs(relativeAngle) < halfHole;

        // Check if the ball is attempting to exit through the hole
        if (distFromCenter + this.radius > circleRadius && isInHoleRange) {
          return true; // Ball has exited through the hole
        }

        // Handle collision with the circle's boundary only if not in the hole's range
        if (distFromCenter + this.radius > circleRadius && !isInHoleRange) {
          // Calculate normal vector
          const normalX = distX / distFromCenter;
          const normalY = distY / distFromCenter;

          // Calculate velocity dot normal
          const dotProduct = this.dx * normalX + this.dy * normalY;

          // Reflect the velocity with added randomness
          // Standard reflection
          let newDx = this.dx - 2 * dotProduct * normalX;
          let newDy = this.dy - 2 * dotProduct * normalY;

          // Add slight randomness to the reflection
          const randomFactor = 0.3; // Adjust for more/less randomness
          newDx += (Math.random() - 0.5) * randomFactor;
          newDy += (Math.random() - 0.5) * randomFactor;

          this.dx = newDx;
          this.dy = newDy;

          // Reposition the ball just inside the boundary to prevent sticking
          this.x = centerX + normalX * (circleRadius - this.radius - 1);
          this.y = centerY + normalY * (circleRadius - this.radius - 1);
        }

        return false; // Ball has not exited
      }
    }

    // Function to spawn a new ball
    function spawnBall(initial = true) {
      const colors = ['red', 'green', 'blue', 'yellow', 'purple', 'orange', 'cyan', 'magenta'];
      const color = colors[Math.floor(Math.random() * colors.length)];
      const speed = initial ? (Math.random() * 2 + 2) : (Math.random() * 3 + 1.5);
      // Random direction
      const angle = Math.random() * 2 * Math.PI;
      const dx = Math.cos(angle) * speed;
      const dy = Math.sin(angle) * speed;
      const ball = new Ball(centerX, centerY, 10, dx, dy, color);
      balls.push(ball);
    }

    // Function to draw the spinning circle with a hole
    function drawSpinningCircle() {
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(angle);
      ctx.translate(-centerX, -centerY);
      ctx.beginPath();
      // Draw the circle with a hole by skipping the hole's arc
      ctx.arc(centerX, centerY, circleRadius, holeAngle / 2, 2 * Math.PI - holeAngle / 2);
      ctx.lineWidth = 5;
      ctx.strokeStyle = 'white';
      ctx.stroke();
      ctx.restore();
    }

    // Function to draw the counter on the canvas
    function drawCounter() {
      ctx.font = '24px Arial';
      ctx.fillStyle = 'white';
      ctx.textAlign = 'center';
      ctx.fillText(`Balls Exited: ${exitCount}`, centerX, 40);
    }

    // Animation loop
    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw spinning circle with hole
      drawSpinningCircle();

      // Draw the counter
      drawCounter();

      // Update and draw balls
      for (let i = balls.length - 1; i >= 0; i--) {
        const ball = balls[i];
        ball.draw();
        if (ball.update()) {
          // Ball has exited through the hole
          balls.splice(i, 1); // Remove the exited ball
          exitCount++;
          updateCounterDisplay();
          // Spawn two new balls
          spawnBall(false);
          spawnBall(false);
        }
      }

      // Spin the circle
      angle += 0.02; // Adjust rotation speed as needed
      angle %= 2 * Math.PI; // Keep the angle within 0 to 2Ï€

      animationId = requestAnimationFrame(animate);
    }

    // Function to update the counter display (if using a separate div)
    function updateCounterDisplay() {
      // Uncomment the line below if using the separate counter div
      // counterDisplay.textContent = `Balls Exited: ${exitCount}`;
    }

    // Start the game
    startBtn.addEventListener('click', () => {
      if (!gameStarted) {
        gameStarted = true;
        balls = []; // Clear existing balls
        exitCount = 0; // Reset counter
        updateCounterDisplay();
        spawnBall(); // Spawn the first ball
        animate();   // Start animation loop
      }
    });

    // Reset the game
    resetBtn.addEventListener('click', () => {
      cancelAnimationFrame(animationId); // Stop the animation
      gameStarted = false;
      balls = []; // Clear all balls
      exitCount = 0; // Reset counter
      ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
      angle = 0; // Reset rotation angle
      updateCounterDisplay();
    });

    // Optional: Allow resetting by pressing the 'R' key and starting with 'S'
    document.addEventListener('keydown', (e) => {
      if (e.key === 's' || e.key === 'S') {
        startBtn.click();
      }
      if (e.key === 'r' || e.key === 'R') {
        resetBtn.click();
      }
    });
  </script>

</body>
</html>